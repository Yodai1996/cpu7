2018/10/17
05-181029
楊博

レポート2

[問1]

let rec x x = 
	let x = 
		let x = x - (-x) 
		in x - (let x = -x in x - (-x)) in
	x - (-x) in
let x = x 125 in x - (-x)

これをK正規化すると、以下のようになる。

let rec x x = 
	let x = 
		let x = 
			let a = -x 
			in x - a 
		in
		let b = 
			let x = -x 
			in 
			let c = -x 
			in x - c 
		in x - b 
	in 
	let d = -x
	in x - d 
in
let x = x 125 in let e = -x in x - e

これをα変換すると、

let rec x x1 =
	let x2 = 
		let x3 = 
			let a = -x1
			in x1 - a 
		in
		let b = 
			let x4 = -x3
			in 
			let c = -x4 
			in x4 - c 
		in x3 - b 
	in
	let d = -x2
	in x2 - d 
in
let x5 = x 125 in let e = -x5 in x5 - e

また、K正規化した式をA正規化し、適宜α変換を施すと、以下のようになる。

let rec x x1 =
	let a = -x1 in
	let x3 = x1 - a in
	let x4 = -x3 in
	let c = -x4 in
	let b = x4 - c in
	let x2 = x3 - b in
	let d = -x2 in
	x2 - d 
in
let x5 = x 125 in 
let e = -x5 in 
x5 - e

これらの出力はどれも3000で同じになる。

[問2]

共通部分式削除

<実装したこと>
・(1) int + int 同士の削除
・(2) int + var 同士の削除
・(3) var + int 同士の削除
・ネストしたlet式の内部で最も中にあるlet式でも(1)(2)(3)ができる。

<実装したかったが期限に間に合わなかったもの>
・内部でletがネストされているlet式同士の共通部分式削除
	これは、k正規化によって変数が別々の名前にされてしまったことに起因する。
	次回以降削除方法を模索してい。
	もしこれが実装できれば、3項以上の四則演算についても共通部分式があれば、削除できる。

<実装しなかったこと>
・var + int と int + var が等しい時の削除
	演算の左結合性を無視することになるので、実装しなかった。
・参照型は出現を許していない
・関数適応の共通部分削除は自由変数の扱いが難しく、実装していない

<具体的な方法>
elimsubexp.mli elimsubexp.mlにコードを書いた。
与えられたmin-camlの実装だと、int値はk正規化の段階ですべて変数に入れられるため、int値がint値であるとわかるような名前にして、これらはglobalに持っておく。(KNormal.Int 5	なら、Int5という名前をつける)
(KNormal.t * Id.t * int) list ref 型の既出の表現とその名前を保持する環境を作る。
環境は参照型にして、Intから始まる名前の変数をglobalに持てるようにした。
また、ネストされたlet式については、スコープをはっきりさせるため、depthという、深さを表すパラメタと共に環境で変数を保持した。
let 式で新たに定義される変数について、その変数が表す表現が環境にあるかどうかを確認し、無かったらその表現と変数名とスコープを追加、有ったらその表現に対応する変数名を取り出してくる。
また、スコープを抜けたとき、スコープ内の変数を環境から削除する。

たとえば以下のコードをコンパイルする。
=================================================================================================
let x = 5 in
let c = 
	let a = x + 2 in
	let b = x + 2 in
	x + 2
in
let d = x + 2 in
print_int 1
=================================================================================================

実行コマンドは以下の通り
=================================================================================================
./min-caml -syntax -knormal -alpha -elimsubexp test/cse2
=================================================================================================

出力結果は以下の通り
<dump after alpha>
=================================================================================================
<LET> x.1
.   <INT> 5
<IN>
<LET> c.2
.   <LET> a.4
.   .   <LET> Int2
.   .   .   <INT> 2
.   .   <IN>
.   .   <ADD> 
.   .   .   x.1
.   .   .   Int2
.   <IN>
.   <LET> b.5
.   .   <LET> Int2
.   .   .   <INT> 2
.   .   <IN>
.   .   <ADD> 
.   .   .   x.1
.   .   .   Int2
.   <IN>
.   <LET> Int2
.   .   <INT> 2
.   <IN>
.   <ADD> 
.   .   x.1
.   .   Int2
<IN>
<LET> d.3
.   <LET> Int2
.   .   <INT> 2
.   <IN>
.   <ADD> 
.   .   x.1
.   .   Int2
<IN>
<LET> Int1
.   <INT> 1
<IN>
<EXTFUNAPP> 
.   <FUN> print_int
.   <ARGS> Int1, </ARGS> 
=================================================================================================

<dump after elimsubexp>
=================================================================================================
<LET> x.1
.   <INT> 5
<IN>
<LET> c.2
.   <LET> a.4
.   .   <LET> Int2
.   .   .   <INT> 2
.   .   <IN>
.   .   <ADD> 
.   .   .   x.1
.   .   .   Int2
.   <IN>
.   <LET> b.5
.   .   <VAR> a.4
.   <IN>
.   <LET> Int2
.   .   <INT> 2
.   <IN>
.   <ADD> 
.   .   x.1
.   .   Int2
<IN>
<LET> d.3
.   <LET> Int2
.   .   <INT> 2
.   <IN>
.   <ADD> 
.   .   x.1
.   .   Int2
<IN>
<LET> Int1
.   <INT> 1
<IN>
<EXTFUNAPP> 
.   <FUN> print_int
.   <ARGS> Int1, </ARGS>
=================================================================================================

以上より、末端のletの式同士の削除は成功している(a.4とb.5)が、ネストされたlet 同士の共通部分式削除は成功していないことがわかる(c.2とd.3)。

レポートの分量が増えるので結果は載せないが、test/cse2.mlをコンパイルすると、3項からなる式の共通部分式削除ができていないことなどが確認できる。

[問3]

インライン展開に伴い、α変換しないとコードの意味が変わってしまう例としては、以下のようなものが挙げられる。

let rec f x = 
	let y = 1 in x
in
let y = 2 in f y

をインライン展開のみ行い、α変換しないと、以下のような結果になる。

let rec f x =
	let y = 1 in x
in
let y = 2 in let y = 1 in y

これでは結果が変わってしまうため、α変換が必要である。

インライン展開に伴い、その他最適化をすると、最適化ループが終わらなくなる例としては、以下のようなものが挙げられる。

let rec f x =
	if x < 1 then 1
	else f (x - 1)

let rec f x =
	if x < 1 then 1
	else if x - 1 < 1 then 1
		 else f ((x - 1) - 1)

定数畳み込みをすると、

let rec f x =
	if x < 2 then 1 
	else f ((x-1) - 1)

元通りになるので、展開がおわらない。
