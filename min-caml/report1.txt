2018/10/10
05-181029
楊博

レポート1

[問1]

表示できるようにしたのは、kNormal前、α変換の後、closure変換のあとである。
まず、id.mlで宣言されている型tをprintする関数print_tを定義した。
Id.t型をprintするときは、このId.print_tを使うことにした。
次に、syntax.mlにprint_stringとprint_codeという相互再帰する2つの関数を作った。
print_stringではSyntax.tの型宣言に従って、その内容を再帰的にprintしていった。
print_codeでは、再帰から戻ってきた時に、すでに改行されているかを判断し、すでに前に再帰で帰ってきた時に改行していたら何か書かない限り改行をしないという仕組みを実装した。
これには参照型のフラグを用意することによって実現した。
Syntax.t型をdumpしたいときはSyntax.print_codeを呼びだせば良い。
この関数を呼び出すのは、kNormal.mlの関数fの中であり、k正規化をする前に、expressionをdumpするのに使う。
このときKNormal.fにdumpするかどうかのフラグを設置した。

<syntax.ml>より一部抜粋
=================================================================================================
let newline_flag = ref 0

let is_already_newline flag = 
	if !flag = 0 then (print_newline (); flag := 1)
	else ()

let rec print_syntax depth expr =
	print_indent depth; newline_flag := 0;
	match expr with
	| ...
	| ...
and print_code depth expr = print_syntax depth expr; is_already_newline newline_flag
=================================================================================================

そして、kNormal.mlに、print_kNormalとprint_codeという相互再帰する2つの関数を作った。
これはSyntax.print_code同様、print_kNormalが多重再帰から帰ってきた時に、何度も改行しないように、print_codeでフラグを使って開業するかどうかを管理している。
この関数を呼び出すのは、alpha.mlの関数fの中と、closure.mlの関数fの中であり、それぞれの変換が終わったあとの状態をdumpする。
そして、beta.mlの関数fを改変し、β簡約後のexpressionをdumpすることができるようにした。

<kNormal.ml>より一部抜粋
=================================================================================================
let f print_flag e =
	if print_flag = 1 
		then (Syntax.print_code 0 e; fst (g M.empty e)) 
		else fst (g M.empty e)
=================================================================================================

また、dumpするかどうかは、main関数内のコマンドラインオプションの部分に、
-knormal または -kNormal 
-alpha
-beta
-closure
でそれぞれの段階でdumpできるようにした。

以上の実行結果は、以下のようになる。

次のコードの最適化の様子をdumpする。

<test/fib.ml>
=================================================================================================
let rec fib n =
  if n <= 1 then n else
  fib (n - 1) + fib (n - 2) in
print_int (fib 15)
=================================================================================================

<実行コマンド>
=================================================================================================
$ ./min-caml -kNormal -alpha -closure test/fib
=================================================================================================

<-kNormal前の出力>
=================================================================================================
<LETREC> fib
.   <ARGS> n,  </ARGS>
.   .   <IF>
.   .   .   <LE>
.   .   .   .   <VAR> n
.   .   .   .   <INT> 1
.   .   <THEN>
.   .   .   <VAR> n
.   .   <ELSE>
.   .   .   <ADD> 
.   .   .   .   <APP> 
.   .   .   .   .   <VAR> fib
.   .   .   .   .   <SUB> 
.   .   .   .   .   .   <VAR> n
.   .   .   .   .   .   <INT> 1
.   .   .   .   <APP> 
.   .   .   .   .   <VAR> fib
.   .   .   .   .   <SUB> 
.   .   .   .   .   .   <VAR> n
.   .   .   .   .   .   <INT> 2
<IN>
.   <APP> 
.   .   <VAR> print_int
.   .   <APP> 
.   .   .   <VAR> fib
.   .   .   <INT> 15
=================================================================================================

<-alpha後の出力>
=================================================================================================
<LETREC> fib.10
.   <ARGS> n.11, </ARGS>
.   <LET> Ti3.14
.   .   <INT> 1
.   <IN>
.   .   <IF> 
.   .   .   <LE> 
.   .   .   .   n.11
.   .   .   .   Ti3.14
.   .   .   <VAR> n.11
.   .   .   <LET> Ti6.15
.   .   .   .   <LET> Ti5.19
.   .   .   .   .   <LET> Ti4.20
.   .   .   .   .   .   <INT> 1
.   .   .   .   .   <IN>
.   .   .   .   .   .   <SUB> 
.   .   .   .   .   .   .   n.11
.   .   .   .   .   .   .   Ti4.20
.   .   .   .   <IN>
.   .   .   .   .   <APP> 
.   .   .   .   .   .   <FUN> fib.10
.   .   .   .   .   .   <ARGS> Ti5.19, </ARGS> 
.   .   .   <IN>
.   .   .   .   <LET> Ti9.16
.   .   .   .   .   <LET> Ti8.17
.   .   .   .   .   .   <LET> Ti7.18
.   .   .   .   .   .   .   <INT> 2
.   .   .   .   .   .   <IN>
.   .   .   .   .   .   .   <SUB> 
.   .   .   .   .   .   .   .   n.11
.   .   .   .   .   .   .   .   Ti7.18
.   .   .   .   .   <IN>
.   .   .   .   .   .   <APP> 
.   .   .   .   .   .   .   <FUN> fib.10
.   .   .   .   .   .   .   <ARGS> Ti8.17, </ARGS> .   .   .   .   <IN> .   .   .   .   .   <ADD> 
.   .   .   .   .   .   Ti6.15
.   .   .   .   .   .   Ti9.16
<IN>
.   <LET> Ti2.12
.   .   <LET> Ti1.13
.   .   .   <INT> 15
.   .   <IN>
.   .   .   <APP> 
.   .   .   .   <FUN> fib.10
.   .   .   .   <ARGS> Ti1.13, </ARGS> 
.   <IN>
.   .   <EXTFUNAPP> 
.   .   .   <FUN> print_int
.   .   .   <ARGS> Ti2.12, </ARGS>
=================================================================================================

<-closure後の出力>
=================================================================================================
<LETREC> fib.10
.   <ARGS> n.11, </ARGS>
.   <LET> Ti3.14
.   .   <INT> 1
.   <IN>
.   .   <IF> 
.   .   .   <LE> 
.   .   .   .   n.11
.   .   .   .   Ti3.14
.   .   .   <VAR> n.11
.   .   .   <LET> Ti4.20
.   .   .   .   <INT> 1
.   .   .   <IN>
.   .   .   .   <LET> Ti5.19
.   .   .   .   .   <SUB> 
.   .   .   .   .   .   n.11
.   .   .   .   .   .   Ti4.20
.   .   .   .   <IN>
.   .   .   .   .   <LET> Ti6.15
.   .   .   .   .   .   <APP> 
.   .   .   .   .   .   .   <FUN> fib.10
.   .   .   .   .   .   .   <ARGS> Ti5.19, </ARGS> 
.   .   .   .   .   <IN>
.   .   .   .   .   .   <LET> Ti7.18
.   .   .   .   .   .   .   <INT> 2
.   .   .   .   .   .   <IN>
.   .   .   .   .   .   .   <LET> Ti8.17
.   .   .   .   .   .   .   .   <SUB> 
.   .   .   .   .   .   .   .   .   n.11
.   .   .   .   .   .   .   .   .   Ti7.18
.   .   .   .   .   .   .   <IN>
.   .   .   .   .   .   .   .   <LET> Ti9.16
.   .   .   .   .   .   .   .   .   <APP> 
.   .   .   .   .   .   .   .   .   .   <FUN> fib.10
.   .   .   .   .   .   .   .   .   .   <ARGS> Ti8.17, </ARGS> 
.   .   .   .   .   .   .   .   <IN>
.   .   .   .   .   .   .   .   .   <ADD> 
.   .   .   .   .   .   .   .   .   .   Ti6.15
.   .   .   .   .   .   .   .   .   .   Ti9.16
<IN>
.   <LET> Ti1.13
.   .   <INT> 15
.   <IN>
.   .   <LET> Ti2.12
.   .   .   <APP> 
.   .   .   .   <FUN> fib.10
.   .   .   .   <ARGS> Ti1.13, </ARGS> 
.   .   <IN>
.   .   .   <EXTFUNAPP> 
.   .   .   .   <FUN> print_int
.   .   .   .   <ARGS> Ti2.12, </ARGS> 
=================================================================================================

[問2]

lexer.mllに次のようなコードを追加した。
=================================================================================================
let space = [' ' '\t']
let digit = ['0'-'9']
let lower = ['a'-'z']
let upper = ['A'-'Z']
let newline = ['\n' '\r'] (* space から\n と \r を新しく作ったnewlineの方に移した *)

rule token = parse
| newline
	{ Lexing.new_line lexbuf; token lexbuf } (* 改行されるたびにLexing.new_lineでlex_curr_pを更新 *)
=================================================================================================

また、parser.mlyのexp:の中のerrorマッチングの部分で、以下のコードを追加した。

=================================================================================================
| error
    { failwith
        (Printf.sprintf "parse error near line %d characters %d-%d"
		   ((Parsing.symbol_start_pos ()).Lexing.pos_lnum) (* ここで行数を得る *)
           ((Parsing.symbol_start_pos ()).Lexing.pos_cnum - (Parsing.symbol_start_pos ()).Lexing.pos_bol) (* 開始位置 *)
           ((Parsing.symbol_end_pos ()).Lexing.pos_cnum - (Parsing.symbol_start_pos ()).Lexing.pos_bol)) } (* 終了位置 *)
=================================================================================================

このようにすると、parse errorになった時に、エラーの行数と、その行内での場所がわかる。

以下のコードをコンパイルしてみた。(左の数字は行番号)

<test/parse_error.ml>
=================================================================================================
1   |
2   |
3   |
4   |
5   |
6   |
7   |
8   |let + with + try
9   |
10  |
11  |let a = 1 in in in print_int a a
12  |
=================================================================================================

<実行コマンド>
=================================================================================================
$ ./min-caml test/parse_error
=================================================================================================

<出力結果>
=================================================================================================
Fatal error: exception Failure("parse error near line 8 characters 4-5")
=================================================================================================

このように、はじめてparse errorになった部分の正確な位置が返されていることがわかる。


[問3]
理解が追いついておらず、まだやっていません。完成し次第、遅れて提出します。
